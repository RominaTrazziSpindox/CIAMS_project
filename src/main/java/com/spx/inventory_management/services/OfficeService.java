package com.spx.inventory_management.services;

import com.spx.inventory_management.dto.OfficeRequestDTO;
import com.spx.inventory_management.dto.OfficeResponseDTO;
import com.spx.inventory_management.mappers.OfficeMapper;
import com.spx.inventory_management.models.Office;
import com.spx.inventory_management.repositories.OfficeRepository;
import com.spx.inventory_management.utils.normalizer.OfficeRequestNormalizer;
import com.spx.inventory_management.utils.TextNormalizer;
import com.spx.inventory_management.utils.validator.CreateValidator;
import com.spx.inventory_management.utils.validator.ReadValidator;
import jakarta.persistence.EntityNotFoundException;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
@Slf4j
public class OfficeService {

    @Autowired
    private OfficeRepository officeRepository;

    @Autowired
    private ReadValidator readValidator;

    @Autowired
    private CreateValidator createValidator;

    @Autowired
    private OfficeMapper officeMapper;


    // ==========================================================
    // CRUD METHODS - From Repository Layer
    // ==========================================================

    // ==========================================================
    // READ OPERATIONS
    // ==========================================================

    /**
     * Gets all offices.
     *
     * @return the all offices
     */
    @Cacheable("offices-all")
    public List<OfficeResponseDTO> getAllOffices() {

        log.info("Service getAllOffices");

        /* Uses OfficeMapperImpl (auto-generated by MapStruct)
        to convert each Office entity into a DTO object. */
        return officeRepository.findAll()
                                .stream()
                                .map(officeMapper::toDTO)
                                .toList();
    }


    /**
     * Gets office by name.
     *
     * @param name the name
     * @return the office by name
     */
    @Cacheable(value = "offices-by-name", key = "T(com.spx.inventory_management.utils.TextNormalizer).normalizeKey(#name)")
    public OfficeResponseDTO getOfficeByName(String name) {

        // Step 1: Check if the input Office entity is found and validate its name
        Office office = readValidator.checkIfEntityIsFound("Office", name, officeRepository::findByNameIgnoreCase);

        log.info("Service getOfficeByName");

        // Step 2: Mapper converts the entity into a DTO for response.
        return officeMapper.toDTO(office);
    }


    // ==========================================================
    // CREATE OPERATION
    // ==========================================================

    /**
     * Create office office response dto.
     *
     * @param newOfficeDTO the new office dto
     * @return the office response dto
     */
    @Transactional
    @CacheEvict(value = { "offices-all", "offices-by-name" }, allEntries = true)
    public OfficeResponseDTO createOffice(OfficeRequestDTO newOfficeDTO) {

        // Step 1. Check if the input Office entity already exists and validate its fields
        OfficeRequestDTO normalizedDTO = createValidator.checkIfEntityAlreadyExists("Office", newOfficeDTO,
               dto -> officeRepository.existsByNameIgnoreCase(dto.getOfficeName()), OfficeRequestNormalizer::normalize);

        // Step 2. Convert DTO -> Entity (Database added an id automatically)
        Office newOfficeEntity = officeMapper.toEntity(normalizedDTO);

        // Step 3. Save the entity into the database
        Office savedOfficeEntity = officeRepository.save(newOfficeEntity);

        log.info("Office created. Name: {}", savedOfficeEntity.getName());

        // Step 4. Convert Entity -> DTO
        return officeMapper.toDTO(savedOfficeEntity);
    }


    // ==========================================================
    // UPDATE OPERATION
    // ==========================================================

    /**
     * Update existing office by name office response dto.
     *
     * @param currentName  the current name
     * @param newOfficeDTO the new office dto
     * @return the office response dto
     */
    @Transactional
    @CacheEvict(value = { "offices-all", "offices-by-name" }, allEntries = true)
    public OfficeResponseDTO updateExistingOfficeByName(String currentName, OfficeRequestDTO newOfficeDTO) {

        // Step 1: Normalize the current name
        String normalizedCurrentName = TextNormalizer.normalizeKey(currentName);

        // Step 2: Normalize incoming new office data
        OfficeRequestDTO normalizedNewOffice = OfficeRequestNormalizer.normalize(newOfficeDTO);

        // Step 3: Retrieve the existing office or throw if not found.
        Office existingOffice = officeRepository.findByNameIgnoreCase(normalizedCurrentName).orElseThrow(() -> {
            log.error("Update failed. Office not found. Name: {}", normalizedCurrentName);
            return new EntityNotFoundException("Office not found");
        });

        // Step 4: Extract the new office name
        String newOfficeName = normalizedNewOffice.getOfficeName();

        // Step 5: If the newName IS NOT EQUAL to the currentName AND if the newName already exists into the database...
        if (!normalizedCurrentName.equalsIgnoreCase(newOfficeName) && officeRepository.existsByNameIgnoreCase(newOfficeName)) {
            throw new IllegalArgumentException("Office name already exists: " + newOfficeName);
        }

        // Step 6: Update only mutable fields (in this case: office name).
        existingOffice.setName(newOfficeName);

        // Step 7: Save the new updated Office into the database
        Office updatedOffice = officeRepository.save(existingOffice);

        log.info("Office updated. OldName: {}, NewName: {}", normalizedCurrentName, newOfficeName);

        // Step 8: Convert Entity -> DTO
        return officeMapper.toDTO(updatedOffice);
    }


    // ==========================================================
    // DELETE OPERATION
    // ==========================================================

    /**
     * Delete office by name.
     *
     * @param officeName the office name
     */
    @Transactional
    @CacheEvict(value = { "offices-all", "offices-by-name" }, allEntries = true)
    public void deleteOfficeByName(String officeName) {

        // Step 1: Normalize the office name
        String normalizedName = TextNormalizer.normalizeKey(officeName);

        // Step 2: Validate entity existence before deletion.
        if (!officeRepository.existsByNameIgnoreCase(normalizedName)) {
            log.error("Delete failed. Office not found. Name: {}", normalizedName);
            throw new EntityNotFoundException("Office not found");
        }

        // Step 3: Proceed with deletion.
        officeRepository.deleteByNameIgnoreCase(normalizedName);

        log.info("Deleting office. Named: {}", normalizedName);

    }
}